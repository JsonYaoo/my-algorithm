package com.jsonyao.sort;

/**
 * On: Java Version 1.7
 * 快速排序概念:
 *      a. 快速排序是对冒泡排序的一种改进
 *      b. 它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分, 其中一部分的所有数据都比另外一部分的所有数据都要小, 然后再按此方法
 *         对这两部分数据分别进行快速排序, 整个排序过程可以递归进行, 以此达到整个数据变成有序序列
 * Relation:
 *      a. https://www.cnblogs.com/onepixel/articles/7674659.html
 *      b. https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&fromid=2084344&fr=aladdin
 *      c. https://blog.csdn.net/qq_37941471/article/details/80522354?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param
 */
public class QuickSort {

    public int[] quickSort1(int[] arr, int left, int right){
        /**
         *  左右指针法1:(推荐, 对比第2种写法, 由于是只有满足条件时才执行交换, 大大减少了交换的次数)
         *  A. 核心思想:
         *      a. 将数组的第一个元素left作为基准数pivot
         *      b. 从数组的末尾元素j开始向前找比key小的数, 首元素i开始向后找比pivot大的数, 找到后两者交换(i、j交换的原理是比pivot大的放在右边, 小的放在左边), 直到i>=j终止遍历
         *      c. 最后将j的值和第一个元素交换, 即pivot作为中间数(左区间都是比pivot小的数, 右区间都是比pivot大的数)
         *      d. 再对左右区间重复b、c
         *      e. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         *      g. 该写法时完全是当找到符合条件值时才进行交换, 等于pivot的都忽略不做处理, 最后把关键字移到合适的位置, 大大减少了交换的次数
         * B. 时间复杂度:
         *      a. 对于每趟快速排序, 左右指针循环遍历, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里在外循环退出后, 将等于pivot的元素与j进行了交换, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性, 因此, 快速排序是不稳定的
         */
        int pivot = arr[left];
        int i = left;
        int j = right;

        // 外部循环控制的是该数组快速排序的趟数
        while (i < j){
            // 内部循环控制的是一趟的快速排序: 交换一次(找到符合条件的值时)
            while (i < j && arr[j] >= pivot) j--;// 等于pivot的元素默认为不处理, 由于pivot选择了第1个元素, 必须先让j循环保证退出外循环时交换的是小于等于pivot的值
            while (i < j && arr[i] <= pivot) i++;// 等于pivot的元素默认为不处理

            // 避免i=j时白白浪费一次交换次数
            if(i < j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // 退出外部循环, 代表i与j相遇了, 由于j循环写在了前面, 因此相遇意味着arr[i]=arr[j]<=pivot, 所以交换j的值和pivot时没有问题的
        arr[left] = arr[j];
        arr[j] = pivot;

        // 到这里, 代表基准值pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小), 下面进行左右数组递归快速排序
        if(i-1 > left) {
            // 左数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort1(arr, left, i-1);
        }
        if(j+1 < right){
            // 右数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort1(arr, j+1, right);
        }

        // 经过递归左右排序后, 表示当前层数组已经排序完成
        return arr;

        /**
         * 左右指针法2(不推荐, 由于等于pivot时会执行交换所以交换次数比较多):
         * A. 核心思想:
         *      a. 设要排序的数组是A[0]...A[N-1], 首先任意选取一个数据(通常选用数组的第一个数)作为关键数据, 然后将所有比它小的数都放到
         *      它左边, 所有比它大的数都放到它右边, 这个过程成为一趟快速排序.
         *      b. 设置两个变量i、j, 排序开始的时候: i=0, j=N-1
         *      c. 以第一个数组元素作为关键数据, 赋值给key, 即key=A[0]
         *      d. 从j开始向前搜索, 即由后开始向前搜索(j--), 找到第一个小于key的值A[j], 将A[j]和A[i]的值交换(i、j交换的原理是比pivot大的或者等于的放在右边, 小的或者等于的放在左边)
         *      e. 从i开始向后搜索, 即由前开始向后搜索(i++), 找到第一个大于key的值A[i], 将A[i]和A[j]的值交换(i、j交换的原理是比pivot大的或者等于的放在右边, 小的或者等于的放在左边)
         *      f. 重复d和e, 直到i=j:
         *            1) 如果没有找到符合条件的值, 即d中A[j]都大于key, e中A[i]都小于key, 这时只需要j--,i++即可
         *            2) 如果有找到符合条件的值, 进行交换的时候, 值进行改变, i和j的指针位置不变
         *            3) 而当i=j时, 一定正好时i++或者j--完成的时候, 此时循环结束
         *         或者arr[i] = arr[j] = pivot:
         *            1) 这时只需要i继续向后搜索即可
         *      g. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         *      h. 对比第一种, 由于等于pivot时会打断j或者i的循环, 导致等于pivot的值会进行多次交换(每次交换必定有一个等于pivot可能是i也可能是j), 这增加了不必要的交换次数
         * B. 时间复杂度:
         *      a. 对于每趟快速排序, 左右指针循环遍历, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里等于pivot的元素会发生前后都次交换的, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性, 因此, 快速排序是不稳定的
         */
//        int pivot = arr[left];
//        int i = left;
//        int j = right;
//
//        // 外部循环控制的是该数组快速排序的趟数
//        while (i < j) {
//            // 内部循环控制的是一趟的快速排序: 交换一次 或者 不用交换
//            while (i < j && arr[j] > pivot) j--;// 这里是可以互换j和i的循环次序的, 因为这种写法pivot是会被交换多次的, 不像第1种写法那样, 只在退出外循环时才交换1次
//            while (i < j && arr[i] < pivot) i++;
//            if (i < j) {
//                // i和j未重合时
//                if(arr[i] == arr[j]){
//                    i++;// arr[i] == arr[j]时, 必然是等于关键字pivot的, 这时无需交换i和j的值, 只需要后移i即可
//                }
//                else {
//                    // 不等于关键字时, 交换j和j的值
//                    int temp = arr[i];
//                    arr[i] = arr[j];
//                    arr[j] = temp;
//                }
//            }
//        }
//
//        // 到这里, 代表基准值pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小), 下面进行左右数组递归快速排序
//        if(i-1 > left) {
//            // 左数组存在多于一个元素, 需要进行递归快速排序
//            arr = quickSort1(arr, left, i-1);
//        }
//        if(j+1 < right){
//            // 右数组存在多于一个元素, 需要进行递归快速排序
//            arr = quickSort1(arr, j+1, right);
//        }
//
//        // 经过递归左右排序后, 表示当前层数组已经排序完成
//        return arr;
    }

    public int[] quickSort2(int[] arr, int left, int right){
        /**
         * 挖坑法(推荐, 实现上和性能上有点类似于第1种的左右指针法, 但思路比左右指针法更加形象):
         * A. 核心思想:
         *      a. 定义两个指针left指向起始位置, right指向最后一个元素的位置, 然后指定一个基数pivot作为坑(这里选取第1个元素即left的起始位置对应的值)
         *      b. 然后right从后往前寻找比pivot小的元素, 然后把对应的值赋给left, 这时left坑被填补了, right处就产生了新坑
         *      c. 同理left从前往后寻找比pivot大的元素, 然后把对应的值赋给right, 这时right坑被填补了, left处就产生了新坑
         *      d. 循环b和c, 直到left和right指针相遇, 这时由于right循环写在了前面, 因此相遇意味着arr[right]=arr[left]<=pivot,
         *         所以交换right的值和pivot时没有问题的, 故将pivot的值赋right指针, 填补最后的这个坑, 完成一趟快速排序
         *      e. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         * B. 时间复杂度:
         *      a. 对于每一趟快速排序, 同样也是左右指针遍历, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里在外循环退出后, 可能会将等于pivot的元素会赋值给最后的一个坑, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性, 因此, 快速排序是不稳定的
         */
        int pivot = arr[left];// 备份坑值
        int i = left;// 克隆左指针
        int j = right;// 克隆右指针

        // 外部循环控制的是该数组快速排序的趟数
        while (i < j){
            // 内部循环控制的是一趟的快速排序
            while (i < j && arr[j] >= pivot){// 等于pivot的元素默认为不处理, 由于pivot选择了第1个元素, 必须先让j循环保证初始挖坑时是挖在备份坑值的位置上
                j--;
            }
            arr[i] = arr[j];// 开始挖坑/填坑(第一个坑开始的地方)

            // 继续填坑
            while (i < j && arr[i] <= pivot){
                i++;
            }
            arr[j] = arr[i];
        }

        // i==j后, 使用备份的坑值填补回新坑的位置
        arr[j] = pivot;

        // 到这里, 代表基准值pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小), 下面进行左右数组递归快速排序
        if(i-1 > left) {
            // 左数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort2(arr, left, i-1);
        }
        if(j+1 < right){
            // 右数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort2(arr, j+1, right);
        }

        // 经过递归左右排序后, 表示当前层数组已经排序完成
        return arr;
    }

    public int[] quickSort3(int[] arr, int left, int right){
        /**
         * 前后指针法1(不推荐, 类似于冒泡排序的小值气泡方式, 但由于无论怎么写, 等于pivot都可能会发生多次交换, 性能不高, 且实现方式上从小到大排序的只能规定基准值为right指针, 不灵活):
         * A. 核心思想:
         *      a. 选择数组第一个元素即left指针的值作为基准值pivot
         *      b. 定义两个指针, 一前一后, cur(前指针)指向起始位置, prev(后指针)指向cur的前一个位置
         *      c. cur向前遍历与pivot进行比较:
         *          1) 如果找不到比pivot更大的值, 则cur继续+1, prev保持位置不动
         *          2) 如果找到比pivot更大的值, 则prev+1, 当新的prev指针和cur指针不等时, 则交换新prev的值与cur的值
         *      d. 直到cur走到right的位置, 数组遍历完毕, 最后prev指针+1, 交换新prev的值与right的值, 该快速排序完毕
         *      e. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         * B. 时间复杂度:
         *      a. 对于每一趟快速排序, cur指针遍历, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里在外循环退出后, 可能会将等于pivot的元素重新移动到++prev指针当中, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性, 因此, 快速排序是不稳定的
         */
//        int pivot = arr[right];// 取数组left的值做基准值pivot, 那么意味着前后指针无论选择left还是right, 完成任务后肯定是从大到小排序的, 因为基准值在了第1位, 完成任务后第1为以后的值肯定是越来越小的, 因此, 想要完成任务后从小到大排序, 基准值必须选择right指针
//        int cur = left;// pivot为right指针时, 前后指针选择left还是right都能完成从小到大的任务, 这里选择left指针
//        int prev = left - 1;// 同上, 这里prev选择left-1指针
//
//        while (cur < right) {
//            // 由于cur是遇到<pivot才进行比较/交换, 所以cur只会在>=pivot时才不比较/交换的继续前进, prev才会落后cur, 因此在不等于cur指针时, ++prev指针肯定是指向cur过程中第一个大于等于pivot的值
//            if(arr[cur] < pivot && ++prev != cur){// arr[cur] < pivot代表找到1个比pivot小的, ++prev != cur代表只交换大于等于pivot的值
//                int temp = arr[prev];
//                arr[prev] = arr[cur];
//                arr[cur] = temp;
//            }
//
//            // 有没有发生比较/交换, cur依旧继续前进
//            cur++;
//        }
//
//        // 退出外循环, 代表cur遍历完整个数组:
//        //      a. 如果遍历过程中prev没发生移位, 则代表pivot为最大值, 需要把pivot放在数组的最后
//        //      b. 如果prev发生了移位但没发生过交换, 则代表被cur遍历过的数组为有序数组, 这时pivot小于cur 1位, 这时无需任何操作
//        //      c. 如果prev发生了位移且发生过交换, 由于cur已到达right处, 则代表当前prev到right处全是大于等于pivot的值, 而当前prev的值是比pivot小的, ++prev的值肯定是大于等于pivot的, 因此, 交换++prev与right的值整好能把pivot放到正确的位置上(pivot左边的值都比右边的小)
//        if(++prev != cur){
//            arr[right] = arr[prev];
//            arr[prev] = pivot;// 把pivot放到正确的位置上(pivot左边的值都比右边的小)
//        }
//
//        // 到这里, 代表基准值pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小), 下面进行左右数组递归快速排序
//        if(prev-1 > left) {
//            // 左数组存在多于一个元素, 需要进行递归快速排序
//            arr = quickSort3(arr, left, prev-1);
//        }
//        if(prev+1 < right){
//            // 右数组存在多于一个元素, 需要进行递归快速排序
//            arr = quickSort3(arr, prev+1, right);
//        }
//
//        // 经过递归左右排序后, 表示当前层数组已经排序完成
//        return arr;

        /**
         * 前后指针法2(不推荐, 类似于冒泡排序的小值气泡方式, 等于pivot的可能会发生多次交换, 性能不高, 但思路也算比较清晰):
         * A. 核心思想:
         *      a. 选取数组第一个元素即left指针的值作为基准值pivot
         *      b. 选取pivot+1的值作为index(在i遍历校验时, index始终指向排序后基准值右边数组第1个元素)
         *      c. 赋值index给i, 用i开始遍历和校验index及其后面的数组, 如果i的值小于pivot, 则i值与index值交换位置(保证小于pivot的都在index左边)以及更改index指针位置(值交换位置后, +1位置的值成为了排序后基准值右边数组的第1个元素, 这时index需要+1), 而i无论什么都继续保持向前遍历
         *      d. 直到i遍历完right后退出循环, 这时index指向排序后基准值右边数组第1个元素, 所以需要把index位置-1则得到pivot正确的位置, 再把pivot方法该位置, 该趟快速排序结束
         *      e. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         * B. 时间复杂度:
         *      a. 对于每一趟快速排序, i遍历数组, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里在外循环退出后, 可能会将等于pivot的元素重新移动到--index指针当中, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性, 因此, 快速排序是不稳定的
         */
        int pivot = arr[left];// 选取left的值作为pivot
        int index = left + 1;// 初始时选取left+1作为index

        // index赋值给i, 开始遍历和校验index及其后面的数组
        for(int i = index; i <= right; i++){// 到达right还需要校验right是不是符合条件(小于pivot的在index左边)
            if(arr[i] < pivot){
                // i值与index值交换位置(保证小于pivot的都在index左边)
                int temp = arr[i];
                arr[i] = arr[index];
                arr[index] = temp;

                // 值交换位置后, +1位置的值成为了排序后基准值右边数组的第1个元素, 所以需要更改index指针位置, 但因为index指针需要在循环中保持指向排序后基准值右边数组的第1个元素, 所以只能+1, 不能取i的值
                index++;
            }
        }

        // i遍历校验完毕后, index指针完成任务, 这时-1便得到pivot正确的位置, 再把pivot放到正确的位置, 该趟快速排序结束
        if(--index != left){
            arr[left] = arr[index];
            arr[index] = pivot;
        }

        // 到这里, 代表基准值pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小), 下面进行左右数组递归快速排序
        if(index-1 > left) {
            // 左数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort2(arr, left, index-1);
        }
        if(index+1 < right){
            // 右数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort2(arr, index+1, right);
        }

        // 经过递归左右排序后, 表示当前层数组已经排序完成
        return arr;
    }

    public static void main(String[] args) {
        int[] arr = {
                9, 8, 10, 4, 7, 2, 5, 5
        };

        QuickSort quickSort = new QuickSort();
        arr = quickSort.quickSort3(arr, 0, arr.length-1);
        for(int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
