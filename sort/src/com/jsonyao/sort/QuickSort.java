package com.jsonyao.sort;

/**
 * On: Java Version 1.7
 * 快速排序概念:
 *      a. 快速排序是对冒泡排序的一种改进
 *      b. 它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分, 其中一部分的所有数据都比另外一部分的所有数据都要小, 然后再按此方法
 *         对这两部分数据分别进行快速排序, 整个排序过程可以递归进行, 以此达到整个数据变成有序序列
 * Relation:
 *      a. https://www.cnblogs.com/onepixel/articles/7674659.html
 *      b. https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&fromid=2084344&fr=aladdin
 *      c. https://blog.csdn.net/qq_37941471/article/details/80522354?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param
 */
public class QuickSort {

    public int[] quickSort1(int[] arr, int left, int right){
        /**
         *  左右指针法1:(推荐, 对比第2种写法, 由于是只有满足条件时才执行交换, 大大减少了交换的次数)
         *  A. 核心思想:
         *      a. 将数组的第一个元素left作为基准数pivot
         *      b. 从数组的末尾元素j开始向前找比key小的数, 首元素i开始向后找比pivot大的数, 找到后两者交换(i、j交换的原理是比pivot大的放在右边, 小的放在左边), 直到i>=j终止遍历
         *      c. 最后将j的值和第一个元素交换, 即pivot作为中间数(左区间都是比pivot小的数, 右区间都是比pivot大的数)
         *      d. 再对左右区间重复b、c
         *      e. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         *      g. 该写法时完全是当找到符合条件值时才进行交换, 等于pivot的都忽略不做处理, 最后把关键字移到合适的位置, 大大减少了交换的次数
         * B. 时间复杂度:
         *      a. 对于每趟快速排序, 左右指针循环遍历, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里在外循环退出后, 将等于pivot的元素与j进行了交换, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性,
         *         因此, 快速排序是不稳定的
         */
        int pivot = arr[left];
        int i = left;
        int j = right;

        // 外部循环控制的是该数组快速排序的趟数
        while (i < j){
            // 内部循环控制的是一趟的快速排序: 交换一次(找到符合条件的值时)
            while (i < j && arr[j] >= pivot) j--;// 等于pivot的元素默认为不处理, 由于pivot选择了第1个元素, 必须先让j循环保证退出外循环时交换的是小于等于pivot的值
            while (i < j && arr[i] <= pivot) i++;// 等于pivot的元素默认为不处理

            // 避免i=j时白白浪费一次交换次数
            if(i < j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // 退出外部循环, 代表i与j相遇了, 由于j循环写在了前面, 因此相遇意味着arr[i]=arr[j]<=pivot, 所以交换j的值和pivot时没有问题的
        arr[left] = arr[j];
        arr[j] = pivot;

        // 关键字pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小), 下面进行左右数组递归快速排序
        if(i-1 > left) {
            // 左数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort1(arr, left, i-1);
        }
        if(j+1 < right){
            // 右数组存在多于一个元素, 需要进行递归快速排序
            arr = quickSort1(arr, j+1, right);
        }

        // 经过递归左右排序后, 表示当前层数组已经排序完成
        return arr;

        /**
         * 左右指针法2(不推荐, 由于等于pivot时会执行交换所以交换次数比较多):
         * A. 核心思想:
         *      a. 设要排序的数组是A[0]...A[N-1], 首先任意选取一个数据(通常选用数组的第一个数)作为关键数据, 然后将所有比它小的数都放到
         *      它左边, 所有比它大的数都放到它右边, 这个过程成为一趟快速排序.
         *      b. 设置两个变量i、j, 排序开始的时候: i=0, j=N-1
         *      c. 以第一个数组元素作为关键数据, 赋值给key, 即key=A[0]
         *      d. 从j开始向前搜索, 即由后开始向前搜索(j--), 找到第一个小于key的值A[j], 将A[j]和A[i]的值交换(i、j交换的原理是比pivot大的或者等于的放在右边, 小的或者等于的放在左边)
         *      e. 从i开始向后搜索, 即由前开始向后搜索(i++), 找到第一个大于key的值A[i], 将A[i]和A[j]的值交换(i、j交换的原理是比pivot大的或者等于的放在右边, 小的或者等于的放在左边)
         *      f. 重复d和e, 直到i=j:
         *            1) 如果没有找到符合条件的值, 即d中A[j]都大于key, e中A[i]都小于key, 这时只需要j--,i++即可
         *            2) 如果有找到符合条件的值, 进行交换的时候, 值进行改变, i和j的指针位置不变
         *            3) 而当i=j时, 一定正好时i++或者j--完成的时候, 此时循环结束
         *         或者arr[i] = arr[j] = pivot:
         *            1) 这时只需要i继续向后搜索即可
         *      g. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         *      h. 对比第一种, 由于等于pivot时会打断j或者i的循环, 导致等于pivot的值会进行多次交换(每次交换必定有一个等于pivot可能是i也可能是j), 这增加了不必要的交换次数
         * B. 时间复杂度:
         *      a. 对于每趟快速排序, 左右指针循环遍历, 直到把整个数组遍历完毕, 时间复杂度为O(n), 所以整个快速排序算法的时间复杂度跟划分的趟数有关
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 经过k趟划分即可将数组分成1个元素, n*(1/2)^k=1 => 共k=logn趟,
         *         这时, 整个快速排序的时间复杂度为O(nlogn)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 长度为n的数组需要被划分为n趟, 整个快速排序的时间复杂度为O(n^2)
         *      d. 而经过优化证明, 快速排序的平均时间复杂度是O(nlogn)
         * C. 空间复杂度:
         *      a. 快速排序每趟需要1个元素以及递归栈作为辅助空间
         *      b. 最好的情况下, 每次所选择的关键字恰好将当前数组几乎等分, 所需栈的最大深度为log(n+1)
         *      c. 最坏的情况下, 每次所选择的关键字时当前数组的最大或者最小元素, 这使得每次划分所得的子表中一个为空表, 另一个子表的长度为原表长度-1,
         *         这时, 所需栈的最大深度为n
         *      d. 这样, 快速排序的平均空间复杂度为O(logn)
         * D. 稳定性:
         *      a. 由于这里等于pivot的元素会发生前后都次交换的, 如果数组里存在等于pivot的元素, 那么就会打破数组的稳定性, 因此, 快速排序是不稳定的
         */
//        int pivot = arr[left];
//        int i = left;
//        int j = right;
//
//        // 外部循环控制的是该数组快速排序的趟数
//        while (i < j) {
//            // 内部循环控制的是一趟的快速排序: 交换一次 或者 不用交换
//            while (i < j && arr[j] > pivot) j--;// 这里是可以互换j和i的循环次序的, 因为这种写法pivot是会被交换多次的, 不像第1种写法那样, 只在退出外循环时才交换1次
//            while (i < j && arr[i] < pivot) i++;
//            if (i < j) {
//                // i和j未重合时
//                if(arr[i] == arr[j]){
//                    i++;// arr[i] == arr[j]时, 必然是等于关键字pivot的, 这时无需交换i和j的值, 只需要后移i即可
//                }
//                else {
//                    // 不等于关键字时, 交换j和j的值
//                    int temp = arr[i];
//                    arr[i] = arr[j];
//                    arr[j] = temp;
//                }
//            }
//        }
//
//        // 退出外部循环, 代表该数组的快速排序已经遍历完毕, 关键字pivot已经放到了数组中正确的位置(关键字左边的数据都比右边的小)
//        if(i-1 > left) {
//            // 左数组存在多于一个元素, 需要进行递归快速排序
//            arr = quickSort1(arr, left, i-1);
//        }
//        if(j+1 < right){
//            // 右数组存在多于一个元素, 需要进行递归快速排序
//            arr = quickSort1(arr, j+1, right);
//        }
//
//        // 经过递归左右排序后, 表示当前层数组已经排序完成
//        return arr;
    }

    public int[] quickSort2(int[] arr, int left, int right){
        /**
         * 挖坑法:
         * A. 基本思想:
         *      a. 定义两个指针left指向起始位置, right指向最后一个元素的位置, 然后指定一个基数pivot作为坑(这里选取第1个元素即left的起始位置对应的值)
         *      b. 然后right从后往前寻找比pivot小的元素, 然后把对应的值赋给left, 这时left坑被填补了, right处就产生了新坑
         *      c. 同理left从前往后寻找比pivot大的元素, 然后把对应的值赋给right, 这时right坑被填补了, left处就产生了新坑
         *      d. 循环b和c, 直到left和right指针相遇, 这时由于right循环写在了前面, 因此相遇意味着arr[right]=arr[left]<=pivot,
         *         所以交换right的值和pivot时没有问题的, 故将pivot的值赋right指针, 填补最后的这个坑, 完成一趟快速排序
         *      g. 经过n趟的快速排序：
         *            1）左数组只存在一个元素或者没有元素时, 则左数组排序完成
         *            2）右数组只存在一个元素或者没有元素时, 则右数组排序完成
         *            3) 此时, 整个数组排序完成
         */




        return arr;
    }

    public static void main(String[] args) {
        int[] arr = {
                9, 8, 10, 4, 7, 2, 5
        };

        QuickSort quickSort = new QuickSort();
        arr = quickSort.quickSort1(arr, 0, arr.length-1);
        for(int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
