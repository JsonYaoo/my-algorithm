package com.jsonyao.sort;

/**
 * On: Java Version 1.7
 * 插入排序概念:
 *      a. 插入排序, 一般也被成为直接插入排序. 对于少量元素的排序, 它是一个有效的算法
 *      b. 插入排序是一种简单的排序方法, 通过构建有序序列, 对于未排序数据, 在已排序序列中从后向前扫描, 找到相应位置并插入
 *      c. 插入排序的工作方式像排序一手扑克牌. 开始时, 我们的左手为空并且桌子上的牌向下. 然后, 每次牌堆顶部拿走一张牌并将它插入左手中
 *         正确的位置. 这时, 为了找到一张牌的正确位置, 我们从右到左将它与已在手中的每张牌进行比较. 最后拿在左手上的牌总是牌总是排序号的
 *  Relation:
 *      a. https://www.cnblogs.com/onepixel/articles/7674659.html
 *      b. https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin
 */
public class InsertionSort {

    public void insertionSort(int[] arr){
        /**
         * A. 核心思想:
         *      a. 从第一个元素开始, 认为该元素p已经被排序
         *      b. 取出下一个元素q(当前轮用于比较的元素), 在已经排序的元素序列中从后向前扫描(即扫描有序序列)
         *      c. 如果比较元素q小于已排序元素r1, 需要将元素r1向后移动一个位置(预留位置给元素q)
         *      d. 重复c操作, 直到找到比较元素q大于等于已排序元素rn时，记录rn的下一个位置 或者 根本没找到时记录位置0
         *      e. 将新元素插入到该位置
         *      f. 重复b c d e操作, 直到数组最后一个元素
         * B. 时间复杂度:
         *      a. 在最好的情况下, 待排序数组时有序的, 即当前元素q直接等于或者大于已排序元素, 这时只需要比较1次就好, 重复n-1轮, O(n)
         *      b. 在最坏的情况下, 逆序数组, 每次都要进行比较到头, 每轮比较n-1,n-2,...,1次, t = n(n-1)/2, O(n^2)
         * C. 稳定性:
         *      a. 由于插入排序在比较到相等元素时, 只会把当前元素q插入到rn的后一个位置, 所以不会出现相等元素错位的问题, 所以是稳定的
         *      b. 部分算法的稳定性也会由算法的实现方式来决定的, 所以插入排序写的不好也会写成不稳定的
         * D. 算法分析:
         *      a. 插入排序在实现上, 也是采用了in-place的方式(即原址引用), 只需要用到O(1)的额外空间
         *      b. 但是, 每次都需要从后向前扫描, 把已经排好序的元素逐步后挪, 比冒泡好在不用每次都进行互换位置, 直到找到才插入位置,
         *         而在最坏的情况下, 冒泡排序在每一轮都需要进行移为很多次, 所以这时插入排序比冒泡排序效率更高,
         *         而对于选择排序, 在最坏情况下, 由于每轮只需要互换1次, 互换n-1轮即可完成排序, 所以这时选择排序效率有比插入排序高
         *      c. 综上, 对于极端或者一般情况下, 同时间复杂度中, 可以认为效率方面从高到低有:
         *              选择排序 > 插入排序 > 冒泡排序
         *         而由于选择排序是不稳定的, 所以当考虑双维度排序时, 效率方面从高到低就有:
         *              插入排序 > 冒泡排序
         */
        int preIndex, compare;
        for(int i = 1; i < arr.length; i++){// 从第1个元素p开始(第0元素默认已经排好序), 直到数组最后一个元素
            preIndex = i - 1;// 初始化为最后一个已排序元素r1
            compare = arr[i];// 拿出比较元素q

            while (preIndex >= 0 && arr[preIndex] > compare){
                arr[preIndex+1] = arr[preIndex];// 把已排序元素r1覆盖到比较元素q的位置, 由于已经拿出比较元素q, 所以直接覆盖就行
                preIndex--;// 复制完毕, 继续向前移动指针

                // 同理, 下一轮中由于已经在这轮把r1复制到新的位置了, 所以r2直接覆盖掉旧的r1就行了
            }

            // 直到数组的第一位依然没比较到结果 或者 找到比较元素q大于等于了已排序元素rn时, 插入q到该位置的下一个位置
            arr[preIndex+1] = compare;
        }
    }

    public static void main(String[] args) {
        InsertionSort insertionSort = new InsertionSort();

        int[] arr = new int[]{
                3, 1, 2, 5, 4, 1
        };

        insertionSort.insertionSort(arr);
        for(int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
